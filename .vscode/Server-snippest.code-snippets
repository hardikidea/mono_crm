{
	"Master:Model-Migration": {
		"prefix": "Master:Model-Migration",
		"scope": "javascript,typescript",
		"body": [
		  "'use strict'",
		  "",
		  "/** @type {import('sequelize-cli').Migration} */",
		  "module.exports = {",
		  "  async up(queryInterface, Sequelize) {",
		  "    await queryInterface.createTable('$1', {",
		  "      id: {",
		  "        allowNull: false,",
		  "        autoIncrement: true,",
		  "        primaryKey: true,",
		  "        type: Sequelize.INTEGER,",
		  "      },",
		  "      createdAt: {",
		  "        type: Sequelize.DATE,",
		  "        defaultValue: Sequelize.NOW,",
		  "      },",
		  "      updatedAt: {",
		  "        type: Sequelize.DATE,",
		  "        defaultValue: Sequelize.NOW,",
		  "      },",
		  "      deletedAt: {",
		  "        type: Sequelize.DATE,",
		  "        defaultValue: Sequelize.NOW,",
		  "      },",
		  "    })",
		  "",
		  "    // Add trigger for `updatedAt`",
		  "    await queryInterface.sequelize.query(`",
		  "    CREATE TRIGGER update_updated_at_trigger",
		  "    BEFORE UPDATE ON \"$1\"",
		  "    FOR EACH ROW",
		  "    EXECUTE FUNCTION update_updated_at_column();",
		  "  `)",
		  "  },",
		  "",
		  "  async down(queryInterface, Sequelize) {",
		  "    await queryInterface.dropTable('$1')",
		  "    await queryInterface.sequelize.query(`DROP TRIGGER IF EXISTS update_updated_at_trigger ON \"$1\";`)",
		  "  },",
		  "}",
		  ""
		],
		"description": ""
	},

	"Master:Model": {
		"prefix": "Master:Model",
		"scope": "javascript,typescript",
		"body": [
		  "import { Model, DataTypes, CreationOptional } from 'sequelize'",
		  "import { sequelize } from './sync-model'",
		  "",
		  "class $1 extends Model {",
		  "  declare id: CreationOptional<number>",
		  "}",
		  "",
		  "$1.init(",
		  "  {",
		  "    id: {",
		  "      type: DataTypes.INTEGER.UNSIGNED,",
		  "      autoIncrement: true,",
		  "      primaryKey: true,",
		  "      allowNull: false,",
		  "    },",
		  "  },",
		  "  {",
		  "    sequelize,",
		  "    modelName: '$1',",
		  "    freezeTableName: true,",
		  "    timestamps: true,",
		  "    createdAt: true,",
		  "    updatedAt: true,",
		  "    deletedAt: true,",
		  "    paranoid: true,",
		  "    underscored: false,",
		  "    hasTrigger: false,",
		  "    defaultScope: {",
		  "      attributes: { exclude: [], include: [] },",
		  "    },",
		  "    hooks: {",
		  "      beforeSave: async (instance: $1) => {},",
		  "      beforeUpdate: async (instance: $1) => {},",
		  "      afterSave: async (instance: $1) => {},",
		  "      afterDestroy: async (instance: $1) => {},",
		  "      beforeDestroy: async (instance: $1) => {},",
		  "    },",
		  "  },",
		  ")",
		  "",
		  "export default $1",
		  ""
		],
		"description": ""
	},

	"Master:Repository": {
		"prefix": "Master:Repository",
		"scope": "javascript,typescript",
		"body": [
		  "import { Service } from 'typedi'",
		  "import { GenericRepository } from '../core/generic-repository.service'",
		  "import { $1 } from '../database/models'",
		  "",
		  "@Service()",
		  "export class $1Repository extends GenericRepository<$1> {",
		  "  constructor() {",
		  "    super($1)",
		  "  }",
		  "",
		  "}",
		  ""
		],
		"description": ""
	},

	"Master:Service": {
		"prefix": "Master:Service",
		"scope": "javascript,typescript",
		"body": [
		  "import { Service } from 'typedi'",
		  "import { $1 } from '../database/models'",
		  "import { $1Repository } from '@repository/$2$1.repository'",
		  "import { FindOptions } from 'sequelize'",
		  "import { IWriteRepository, IReadRepository, IDeleteRepository } from '../core/IGenericRepository.interface'",
		  "import { TPaginationData } from '../types/TPaginationData.type'",
		  "",
		  "@Service()",
		  "export class $1Service implements IWriteRepository<$1>, IReadRepository<$1>, IDeleteRepository<$1> {",
		  "  constructor(public $2$1: $1Repository) {}",
		  "  async deleteRecord(option?: FindOptions): Promise<number> {",
		  "    return this.$2$1.delete(option ?? {})",
		  "  }",
		  "  async fetchRecord(option?: FindOptions): Promise<$1 | null> {",
		  "    return await this.$2$1.find(option ?? {})",
		  "  }",
		  "  async fetchAllRecord(option?: FindOptions): Promise<$1[]> {",
		  "    return this.$2$1.findAll(option ?? {})",
		  "  }",
		  "  async fetchById(id: number): Promise<$1 | null> {",
		  "    return this.$2$1.findById(id)",
		  "  }",
		  "  async fetchPagination(page: number, limit: number): Promise<TPaginationData<$1>> {",
		  "    const offset = (page - 1) * limit",
		  "    const dataItems = await this.$2$1.pagination({ limit, offset })",
		  "    return { ...dataItems, currentPage: page }",
		  "  }",
		  "  async createRecord(item: Partial<$1>): Promise<$1> {",
		  "    return await this.$2$1.create(item)",
		  "  }",
		  "  async updateRecord(id: number, item: Partial<$1>, isForceToUpdate: boolean = false): Promise<number> {",
		  "    return await this.$2$1.update(id, item, isForceToUpdate)",
		  "  }",
		  "}",
		  ""
		],
		"description": ""
	},

	"Master:Controller": {
		"prefix": "Master:Controller",
		"scope": "javascript,typescript",
		"body": [
		  "import 'reflect-metadata'",
		  "import { Service } from 'typedi'",
		  "import { NextFunction, Request, Response, Router } from 'express'",
		  "import { $1 } from '@database/models'",
		  "import { $1Service } from '@service/$2$1.service'",
		  "import { CustomError } from '@utils/CustomError'",
		  "import { ValidateRequests } from '@core/validation'",
		  "import { ValidationForCreateSecurityGroup, ValidationForId, ValidationForPagination } from '@validations/index'",
		  "import { Container } from 'typedi'",
		  "",
		  "@Service()",
		  "export class $1Controller {",
		  "  public router: Router",
		  "",
		  "  constructor(public $2$1: $1Service) {",
		  "    this.router = Router()",
		  "    this.initRoutes()",
		  "  }",
		  "",
		  "  initRoutes(): void {",
		  "    // this.initUserTokenRoutes()",
		  "    this.router.get('/', ValidationForPagination, ValidateRequests, this.fetchAll)",
		  "    this.router.get('/:id', ValidationForId, ValidateRequests, this.fetchById)",
		  "    this.router.post('/', ValidationForCreateSecurityGroup, ValidateRequests, this.create)",
		  "    this.router.put('/:id', ValidationForId, ValidateRequests, this.update)",
		  "    this.router.delete('/:id', ValidationForId, ValidateRequests, this.removeById)",
		  "  }",
		  "",
		  "  //initUserTokenRoutes(): void {",
		  "  //  const controller = Container.get(UserTokenMasterController)",
		  "  //  this.router.use('/token', controller.router)",
		  "  //}",
		  "",
		  "  create = async (request: Request, response: Response, next: NextFunction) => {",
		  "    try {",
		  "      const $2$1Create: Partial<$1> = request.body",
		  "      await this.$2$1.createRecord($2$1Create)",
		  "      response.status(200).send({ status: 200, data: `[${$2$1Create.email}] created successfully.` })",
		  "    } catch (error) {",
		  "      response.status(500).send('Internal Server Error')",
		  "    }",
		  "  }",
		  "",
		  "  update = async (request: Request, response: Response, next: NextFunction) => {",
		  "    const id: number = parseInt(request.params.id, 0)",
		  "    try {",
		  "      const $2$1Update: Partial<$1> = request.body",
		  "      const updatedCount = await this.$2$1.updateRecord(id, $2$1Update, true)",
		  "      if (updatedCount > 0) {",
		  "        response.status(200).send({ status: 200, data: `${$1.tableName} [${id}] updated successfully.` })",
		  "      } else {",
		  "        response.status(400).send(`${$1.tableName} provided with [${id}] not found or Invalid Request.`)",
		  "      }",
		  "    } catch (error) {",
		  "      response.status(500).send('Internal Server Error')",
		  "    }",
		  "  }",
		  "",
		  "  fetchById = async (req: Request, res: Response, next: NextFunction) => {",
		  "    const id: number = parseInt(req.params.id, 0)",
		  "    const $2$1Info = await this.$2$1.fetchById(id)",
		  "    if ($2$1Info) {",
		  "      res.status(200).json({ status: 200, data: $2$1Info })",
		  "    } else {",
		  "      next(new CustomError(404, `${$1.tableName} not found with id: [${id}]`))",
		  "    }",
		  "  }",
		  "",
		  "  removeById = async (request: Request, response: Response, next: NextFunction) => {",
		  "    const id: number = parseInt(request.params.id, 0)",
		  "    const is$1Removed = await this.$2$1.deleteRecord({ where: { id } })",
		  "    if (is$1Removed) {",
		  "      response.status(200).json({ status: 200, data: `${$1.tableName}[${id}] removed successfully` })",
		  "    } else {",
		  "      next(new CustomError(404, `${$1.tableName} not found with id: [${id}]`))",
		  "    }",
		  "  }",
		  "",
		  "  fetchAll = async (request: Request, response: Response) => {",
		  "    if (request.query.page && request.query.limit) {",
		  "      const page = parseInt(request.query.page.toString())",
		  "      const limit = parseInt(request.query.limit.toString())",
		  "      response.status(200).send({ status: 200, data: await this.paginationRequest(page, limit) })",
		  "    } else {",
		  "      response.status(200).send({ status: 200, data: await this.fetchAllRecords() })",
		  "    }",
		  "  }",
		  "",
		  "  private async fetchAllRecords() {",
		  "    try {",
		  "      return await this.$2$1.fetchAllRecord({})",
		  "    } catch (error) {",
		  "      console.error('Error fetching fetchAll$1s:', error)",
		  "      throw new CustomError(500, 'Internal Server Error')",
		  "    }",
		  "  }",
		  "",
		  "  private async paginationRequest(page: number, limit: number) {",
		  "    try {",
		  "      return await this.$2$1.fetchPagination(page, limit)",
		  "    } catch (error) {",
		  "      console.error('Error fetching paginationRequest:', error)",
		  "      throw new CustomError(500, 'Internal Server Error')",
		  "    }",
		  "  }",
		  "}",
		  ""
		],
		"description": ""
	},
}